
ServiceManager - это централизованный контейнер для всех сервисов приложения

Cоздается при запуске приложения (внутри статического метода init() класса Zend\Mvc\Application).





Доступные сервисы
1. Application - Позволяет извлечь единственный экземпляр класса Zend\Mvc\Application.
2. ApplicationConfig - Массив конфигурации из файла application.config.php file.
3. Config - Объединенный массив конфигурации из файлов module.config.php, autoload/global.php и autoload/local.php.
4. EventManager - Позволяет извлечь новый экземпляр класса Zend\EventManager\EventManager. Менеджер событий позволяет вызывать события и прикреплять обработчики.
5. SharedEventManager - Позволяет извлечь единственный экземпляр класса Zend\EventManager\SharedEventManager. Общий (shared) менеджер событий позволяет слушать события, определенные в других классах и компонентах.
6. ModuleManager - Позволяет извлечь единственный экземпляр класса Zend\ModuleManager\ModuleManager. Менеджер модулей отвечает за загрузку модулей приложения.
7. Request - Единственный экземпляр класса Zend\Http\Request. Представляет собой HTTP-запрос, полученный от клиента.
8. Response - Единственный экземпляр класса Zend\Http\Response. Представляет собой HTTP-ответ, который будет отправлен клиенту.
9. Router - Единственный экземпляр класса Zend\Router\Http\TreeRouteStack. Осуществляет маршрутизацию URL.
10. ServiceManager - Собственно, сам менеджер сервисов.
11. ViewManager - Единственный экземпляр класса Zend\Mvc\View\Http\ViewManager. Отвечает за подготовку слоя представления к визуализации страницы.





Обычно вы будете извлекать сервисы из менеджера сервисов не в любом месте вашего кода, а внутри фабрики (factory)
Когда вы создаете объект, вы извлечете сервисы, от которых он зависит, и передадите эти сервисы (зависимости) конструктору объекта.
Это также называется внедрением зависимостей (dependency injection).





Отличае от Zend Framework 2:
 - В ZF2 применялся шаблон ServiceLocator, позволяющий извлекать зависимости из менеджера сервисов в любой части приложения
(в контроллерах, других сервисах, и т.д.)
 - В ZF3 же вам придется передавать зависимости принудительно (explicitly). Это немного более утомительно,
но удаляет "скрытые" зависимости и делает ваш код более легким в понимании.




Для переопределения сервиса используется setAllowOverride(), иначе менеджер быбросит исключение




Ленивая загрузка
Минус метода setService() в том, что необходимо создавать экземпляр сервиса
Чтобы сервис был инстанцирован менеджером только тогда, когда кто-нибудь вызовет метод, нужно использовать
 - $serviceManager->setInvokableClass(CurrencyConverter::class);





Фабрики (factories),
Недостаток setInvokableClass(), что он не позволяет передавать параметры (зависимости) сервису во время его инстанцирования
Чтобы разрешить эту проблему нужно использовать фабрики.





Регистрация фабрики для ленивой загрузки
use Zend\ServiceManager\Factory\InvokableFactory;
// Это эквивалентно вызову метода setInvokableClass() из предыдущего раздела.
$serviceManager->setFactory(CurrencyConverter::class, InvokableFactory::class);

После того как вы зарегистрировали фабрику, вы можете извлечь сервис из менеджера сервисов как обычно методом get().
Сервис будет инстанцирован в момент извлечения (ленивая загрузка).





Регистрация фабрики для передачи зависимостей
//CurrencyConverterFactory.php
namespace Application\Service\Factory;

use Zend\ServiceManager\Factory\FactoryInterface;
use Application\Service\CurrencyConverter;

// Класс фабрики
class CurrencyConverterFactory implements FactoryInterface
{
    public function __invoke(ContainerInterface $container, $requestedName, array $options = null)
    {
        // Создание экземпляра класса.
        $service = new CurrencyConverter();

        return $service;
    }
}
$serviceManager->setFactory(CurrencyConverter::class, CurrencyConverterFactory::class);




Регистрация абстрактной фабрики для передачи какие имена сервисов должны быть зарегистрированы во время выполнения

По сравнению с обычным классом фабрики, разница состоит в том,
что обычный класс обычно создает только один сервис,
в то время как абстрактный может динамически создать столько сервисов, сколько необходимо.

Вы можете зарегистрировать абстрактную фабрику с помощью метода setAbstractFactory() менеджера сервисов.

Абстрактная фабрика имеет два метода: canCreate() и __invoke()
canCreate() - для проверки того, может ли фабрика создать сервис с определенным именем
__invoke() - собственно, создать сервис
Оба метода принимают два параметра: менеджер сервисов ($container) и имя сервиса ($requestedName).





Регистрация псевдонима сервиса
$serviceManager->setAlias('CurConv', CurrencyConverter::class);





Общие (shared) и необщие (non-shared) сервисы
Сервисы хранятся в менеджере сервисов в одном экземпляре (шаблон проектирования singleton)
Чтобы создавать новый экземпляр сервиса каждый раз как кто-нибудь извлекает его из менеджера сервисов:
$serviceManager->setShared('EventManager', false);





Конфигурация менеджера сервисов
return [
    // Регистрация сервисов под этим ключом
    'service_manager' => [
        //Регистрация экземпляров классов сервисов
        //позволяет зарегистрировать экземпляры классов
        'services' => [],

        //Регистрация вызываемых классов
        //позволяет зарегистрировать полное имя класса сервиса;
        //сервис будет инстанцирован с использованием ленивой загрузки
        'invokables' => [],

        //Регистрация фабрик
        //позволяет зарегистрировать фабрику, которая сможет создавать экземпляры одного сервиса;
        'factories' => [],


        //Регистрация абстрактных фабрик
        //может быть использован для регистрации абстрактных фабрик,
        //которые могут регистрировать несколько сервисов по имен
        'abstract_factories' => [],

        // Регистрация псевдонимов сервисов
        'aliases' => [],

        // Укажите какие сервисы должны быть non-shared
        'shared' => []
    ],
];


